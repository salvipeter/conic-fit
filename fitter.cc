#include <Eigen/Core>

#include "conic-fit.hh"

using namespace Eigen;
using namespace Geometry;

using Segment = std::array<Point2D, 2>;

namespace ConicFitSolver {
  VectorXd solve(const MatrixXd &M, const MatrixXd &N, double tolerance);
}

// Generated by Gemini
template<int M, int N>
static double lineIntegral(const Segment &s) {
  double x0 = s[0][0], y0 = s[0][1], x1 = s[1][0], y1 = s[1][1];
  double dx = x1 - x0;
  double dy = y1 - y0;

  // Use Binomial Theorem to expand (x0 + dx*t)^M and (y0 + dy*t)^N
  std::array<double, M + 1> x_coeffs;
  std::array<double, N + 1> y_coeffs;
  for (int i = 0; i <= M; ++i)
    x_coeffs[i] = std::tgamma(M + 1) /
      (std::tgamma(i + 1) * std::tgamma(M - i + 1)) * std::pow(x0, i) * std::pow(dx, M - i);
  for (int i = 0; i <= N; ++i)
    y_coeffs[i] = std::tgamma(N + 1) /
      (std::tgamma(i + 1) * std::tgamma(N - i + 1)) * std::pow(y0, i) * std::pow(dy, N - i);

  // Integrate the product of the expansions.  The integral of t^k is t^(k+1)/(k+1)
  double integral = 0.0;
  std::array<double, M + N + 1> result_coeffs;
  result_coeffs.fill(0);
  for (int i = 0; i <= M; ++i)
    for (int j = 0; j <= N; ++j)
      result_coeffs[i+j] += x_coeffs[M-i] * y_coeffs[N-j];

  for (int k = 0; k <= M + N; ++k)
    integral += result_coeffs[k] / (k + 1);

  return integral;
}

// Simple alternative: average of 3 samples.
template <int M, int N>
static double threeSamples(const Segment &s) {
  auto f = [](const Point2D &p) {
    return std::pow(p[0], M) * std::pow(p[1], N);
  };
  return (f(s[0]) + f(s[1]) + f((s[0] + s[1]) / 2)) / 3;
}

// Use just the second point
template <int M, int N>
static double onePoint(const Segment &s) {
  return std::pow(s[1][0], M) * std::pow(s[1][1], N);
}

// Compile-type generated function pointer table generator (generated by ChatGPT)

template <int M, int... Ns>
static constexpr auto makeTableRow(Conic::FitType type, std::integer_sequence<int, Ns...>) {
  return std::array<double(*)(const Segment &), sizeof...(Ns)>{
    (type & Conic::SEGMENT ? &lineIntegral<M, Ns> :
     (type & Conic::MIDPOINT ? &threeSamples<M, Ns> : &onePoint<M, Ns>))...
  };
}

template <int... Ms, int... Ns>
constexpr auto makeTable(Conic::FitType type, std::integer_sequence<int, Ms...>,
                         std::integer_sequence<int, Ns...>) {
  return std::array<std::array<double(*)(const Segment &), sizeof...(Ns)>, sizeof...(Ms)>{
    makeTableRow<Ms>(type, std::integer_sequence<int, Ns...>{})...
  };
}

void Conic::fit(const Conic::Polyline &polyline, Conic::FitType type, double tolerance) {
  MatrixXd M = MatrixXd::Zero(6, 6);
  MatrixXd N = MatrixXd::Zero(6, 6);

  constexpr auto range = std::make_integer_sequence<int, 5>();
  auto table = makeTable(type, range, range);

  bool only_points = !(type & MIDPOINT || type & SEGMENT);
  bool wrap = only_points || type & CLOSED;

  Segment segment;
  double length;
  auto f = [&](int M, int N) {
    auto v = table[M][N](segment);
    if (!only_points)
      v *= length;
    return v;
  };

  double L = 0;
  size_t n = polyline.size();
  for (size_t i = 0; i < n; ++i) {
    if (i == 0) {
      if (wrap)
        segment[0] = polyline[n-1];
      else
        continue;
    } else
      segment[0] = polyline[i-1];
    segment[1] = polyline[i];
    length = (segment[1] - segment[0]).norm();
    L += length;

    M(0, 0) += f(0,0);
    M(1, 0) += f(1,0);
    M(1, 1) += f(2,0);
    M(2, 0) += f(0,1);
    M(2, 1) += f(1,1);
    M(2, 2) += f(0,2);
    M(3, 0) += f(2,0);
    M(3, 1) += f(3,0);
    M(3, 2) += f(2,1);
    M(3, 3) += f(4,0);
    M(4, 0) += f(1,1);
    M(4, 1) += f(2,1);
    M(4, 2) += f(1,2);
    M(4, 3) += f(3,1);
    M(4, 4) += f(2,2);
    M(5, 0) += f(0,2);
    M(5, 1) += f(1,2);
    M(5, 2) += f(0,3);
    M(5, 3) += f(2,2);
    M(5, 4) += f(1,3);
    M(5, 5) += f(0,4);

    N(1, 1) += f(0,0);
    N(2, 2) += f(0,0);
    N(3, 1) += f(1,0) * 2;
    N(3, 3) += f(2,0) * 4;
    N(4, 1) += f(0,1);
    N(4, 2) += f(1,0);
    N(4, 3) += f(1,1) * 2;
    N(4, 4) += f(2,0);
    N(4, 4) += f(0,2);
    N(5, 2) += f(0,1) * 2;
    N(5, 4) += f(1,1) * 2;
    N(5, 5) += f(0,2) * 4;
  }

  if (type & ORIGIN)
    for (size_t i = 0; i < 6; ++i)
      M(i, 0) = 0;

  M /= L;
  N /= L;
  M = M.selfadjointView<Lower>();
  N = N.selfadjointView<Lower>();

  auto s = ConicFitSolver::solve(M, N, tolerance);
  std::copy(s.begin(), s.end(), coeffs.begin());
  if (type & ORIGIN)
    coeffs[0] = 0;
}
