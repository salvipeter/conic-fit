// #define USE_EXACT_LINE_INTEGRAL

#include <Eigen/Core>

#include "conic-fit.hh"

using namespace Eigen;
using namespace Geometry;

using Segment = std::array<Point2D, 2>;

namespace ConicFitSolver {
  VectorXd solve(const MatrixXd &M, const MatrixXd &N, double tolerance);
}

#ifdef USE_EXACT_LINE_INTEGRAL

// Generated by Gemini
template<int M, int N>
double lineIntegral(const Segment &s) {
  double x0 = s[0][0], y0 = s[0][1], x1 = s[1][0], y1 = s[1][1];
  double dx = x1 - x0;
  double dy = y1 - y0;

  // Use Binomial Theorem to expand (x0 + dx*t)^M and (y0 + dy*t)^N
  std::array<double, M + 1> x_coeffs;
  std::array<double, N + 1> y_coeffs;
  for (int i = 0; i <= M; ++i)
    x_coeffs[i] = std::tgamma(M + 1) /
      (std::tgamma(i + 1) * std::tgamma(M - i + 1)) * std::pow(x0, i) * std::pow(dx, M - i);
  for (int i = 0; i <= N; ++i)
    y_coeffs[i] = std::tgamma(N + 1) /
      (std::tgamma(i + 1) * std::tgamma(N - i + 1)) * std::pow(y0, i) * std::pow(dy, N - i);

  // Integrate the product of the expansions.  The integral of t^k is t^(k+1)/(k+1)
  double integral = 0.0;
  std::array<double, M + N + 1> result_coeffs;
  result_coeffs.fill(0);
  for (int i = 0; i <= M; ++i)
    for (int j = 0; j <= N; ++j)
      result_coeffs[i+j] += x_coeffs[M-i] * y_coeffs[N-j];

  for (int k = 0; k <= M + N; ++k)
    integral += result_coeffs[k] / (k + 1);

  return integral;
}

#else  // !USE_EXACT_LINE_INTEGRAL

// Simple alternative: average of 3 samples.
template <int M, int N>
double lineIntegral(const Segment &s) {
  auto f = [](const Point2D &p) {
    return std::pow(p[0], M) * std::pow(p[1], N);
  };
  return (f(s[0]) + f(s[1]) + f((s[0] + s[1]) / 2)) / 3;
}

#endif // USE_EXACT_LINE_INTEGRAL

void Conic::fit(const Conic::Polyline &polyline, double tolerance) {
  MatrixXd M = MatrixXd::Zero(6, 6);
  MatrixXd N = MatrixXd::Zero(6, 6);

  Segment segment;
  double L = 0;
  for (size_t i = 1; i < polyline.size(); ++i) {
    segment[0] = polyline[i-1];
    segment[1] = polyline[i];
    auto length = (segment[1] - segment[0]).norm();
    L += length;

    M(0, 0) += length * lineIntegral<0,0>(segment);
    M(1, 0) += length * lineIntegral<1,0>(segment);
    M(1, 1) += length * lineIntegral<2,0>(segment);
    M(2, 0) += length * lineIntegral<0,1>(segment);
    M(2, 1) += length * lineIntegral<1,1>(segment);
    M(2, 2) += length * lineIntegral<0,2>(segment);
    M(3, 0) += length * lineIntegral<2,0>(segment);
    M(3, 1) += length * lineIntegral<3,0>(segment);
    M(3, 2) += length * lineIntegral<2,1>(segment);
    M(3, 3) += length * lineIntegral<4,0>(segment);
    M(4, 0) += length * lineIntegral<1,1>(segment);
    M(4, 1) += length * lineIntegral<2,1>(segment);
    M(4, 2) += length * lineIntegral<1,2>(segment);
    M(4, 3) += length * lineIntegral<3,1>(segment);
    M(4, 4) += length * lineIntegral<2,2>(segment);
    M(5, 0) += length * lineIntegral<0,2>(segment);
    M(5, 1) += length * lineIntegral<1,2>(segment);
    M(5, 2) += length * lineIntegral<0,3>(segment);
    M(5, 3) += length * lineIntegral<2,2>(segment);
    M(5, 4) += length * lineIntegral<1,3>(segment);
    M(5, 5) += length * lineIntegral<0,4>(segment);

    N(1, 1) += length * lineIntegral<0,0>(segment);
    N(2, 2) += length * lineIntegral<0,0>(segment);
    N(3, 1) += length * lineIntegral<1,0>(segment) * 2;
    N(3, 3) += length * lineIntegral<2,0>(segment) * 4;
    N(4, 1) += length * lineIntegral<0,1>(segment);
    N(4, 2) += length * lineIntegral<1,0>(segment);
    N(4, 3) += length * lineIntegral<1,1>(segment) * 2;
    N(4, 4) += length * lineIntegral<2,0>(segment);
    N(4, 4) += length * lineIntegral<0,2>(segment);
    N(5, 2) += length * lineIntegral<0,1>(segment) * 2;
    N(5, 4) += length * lineIntegral<1,1>(segment) * 2;
    N(5, 5) += length * lineIntegral<0,2>(segment) * 4;
  }

  M /= L;
  N /= L;
  M = M.selfadjointView<Lower>();
  N = N.selfadjointView<Lower>();

  auto s = ConicFitSolver::solve(M, N, tolerance);
  std::copy(s.begin(), s.end(), coeffs.begin());
}
